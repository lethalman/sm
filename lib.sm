id = x: x;

flip = f x y: f y x;

not = x: x == false;

empty? = x:
	if x == [] then true
	else if x == "" then true
	else if eos? x then true
	else false;

foldr = f z s:
	x, ns = s;
	if eos? x then z
	else f x (foldr f z ns);

map = f: foldr (x ns: [f x, ns]) eos;

filter = f: foldr (x ns: if f x then [x, ns] else ns) eos;

head = n s:
	x, ns = s;
	if eos? x then eos
	else if n < 1 then eos
	else [x, head (n-1) ns];

tail = n s:
	go = i xs a:
		x, ns = xs;
		if eos? x then [0, a]
		else (l,t = go (i+1) ns eos;
			  if l < n then [l+1, [x, t]] else [l,t]);
	_, r = go 0 s eos;
	r;
	
takeWhile = f: foldr (x ns: if f x then [x, ns] else eos) eos;

break = p s:
	go = xs a:
		x, ns = xs;
		if eos? x then [a, eos]
		else if p x then [[x,a], ns]
		else (left,right=go ns eos; [[x,left], right]);
	go s eos;

lines = s:
	left, ns = break (x:x=='\n') s;
	if eos? left then eos
	else [string (list left), lines ns];

# Concatenates a stream of streams
catS = s:
	x, xs = s;
	y, ys = x;
	if eos? xs then x
	else if eos? y then catS xs
	else [y, catS [ys, xs]];

zip = sy sx:
	x, xs = sx;
	y, ys = sy;
	if eos? x then eos
	else if eos? y then eos
	else [[x,[y]], zip ys xs];

fst = l:
	x, _ = l;
	x;

# Concatenate two streams
cat = y x:
	catS [x, [y]];

# Flattens a tree of streams
deep = s:
	x, xs = s;
	y, ys = x;
	if eos? xs then [y, deep ys]
	else if eos? y then deep xs
	else [y, deep ys|cat (deep xs)];
	
repeat = x:
	[x, repeat x];
	
pipe = w r:
	x, ns = r;
	if eos? x then w eos
	else pipe (w x) ns;

eols = s: zip (repeat '\n') s|catS;

file1 = read "test.txt";
file2 = read "test2.txt";
file3 = write "test3.txt";
fjson = read "test.json";
fhtml = read "test.html";
fxml = read "test.xml";
zipped = zip (lines file1) (lines file2);

fromXml fxml|eols